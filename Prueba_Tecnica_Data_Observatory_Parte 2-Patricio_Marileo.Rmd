---
title: "Prueba Tecnica Pregunta 2"
author: "P Marileo"
date: "2025-06-04"
output: html_document
---

```{r}
library(dplyr)
library(ggplot2)
library(readr)
library(stringi)
library(stringr)
library(scales)
library(tidyr)
library(factoextra)
library(reshape2)
library(randomForest)
library(clustMixType)

```

```{r}
datos_censo <- read_csv("C:/Users/pmmpm/Downloads/datos/datos_viviendas_censo.csv")
View(datos_censo)
```

```{r}
table(datos_censo$jefe_hogar_sexo)
```
```{r}
M <- 15821 / 31660
F <- 15839 / 31660

cat("Proporci√≥n Hombres:", round(M * 100, 2), "%\n")
cat("Proporci√≥n Mujeres:", round(F * 100, 2), "%\n")
cat("Total:", round((M + F) * 100, 2), "%\n")

```
```{r}

# 1. Crear columnas auxiliares de validaci√≥n
datos_censo <- datos_censo %>%
  mutate(
    total_genero = num_hombres + num_mujeres,
    total_edad = num_menores_18 + num_adultos_18_64 + num_adultos_65_plus,
    valido_genero = total_genero <= num_personas_hogar,
    valido_edad = total_edad <= num_personas_hogar
  )

# 2. Cuantificar inconsistencias
cat("Casos con exceso de g√©nero:", sum(!datos_censo$valido_genero), "\n")
cat("Casos con exceso de edad:", sum(!datos_censo$valido_edad), "\n")
cat("Casos que violan al menos una de las reglas:", sum(!(datos_censo$valido_genero & datos_censo$valido_edad)), "\n")

# 3. Guardar casos eliminados 
casos_invalidos_censo <- datos_censo %>%
  filter(!valido_genero | !valido_edad)

# 4. Eliminar los registros inv√°lidos
datos_censo <- datos_censo %>%
  filter(valido_genero & valido_edad) %>%
  select(-total_genero, -total_edad, -valido_genero, -valido_edad)

```
# Limpieza de Nombres Comunas 

```{r}
datos_censo <- datos_censo %>%
  mutate(comuna = str_to_title(stri_trans_general(comuna, "Latin-ASCII")))

```

```{r}
unique(datos_censo$comuna)
```
```{r}
datos_censo <- datos_censo %>%
  mutate(
    comuna = str_to_title(stri_trans_general(comuna, "Latin-ASCII")),
    comuna = case_when(
      comuna %in% c("Providencia", "Provi") ~ "Providencia",
      comuna %in% c("Vina Del Mar", "Vina", "V. Del Mar") ~ "Vi√±a Del Mar",
      comuna %in% c("Santiago", "Stgo") ~ "Santiago",
      comuna %in% c("Valparaiso", "Valpo") ~ "Valpara√≠so",
      comuna %in% c("Concepcion", "Conce") ~ "Concepci√≥n",
      comuna %in% c("Las Condes", "Condes") ~ "Las Condes",
      TRUE ~ comuna
    )
  )

```

```{r}
unique(datos_censo$comuna)
```

# Validaci√≥n de coherencia interna del hogar:
 Se evalu√≥ que la suma de los miembros por g√©nero (num_hombres + num_mujeres)
 y la suma por grupos etarios (menores de 18, adultos 18-64, adultos 65+)
 no excediera el total de personas declaradas en el hogar (num_personas_hogar).

# Esta validaci√≥n garantiza que no existan m√°s personas clasificadas dentro del hogar
 de las que el mismo registro declara como total
 
 
```{r}
hist(datos_censo$num_dormitorios,
     breaks = 20,
     col = "skyblue",
     main = "Distribuci√≥n de Dormitorios",
     xlab = "Dormitorio",
     ylab = "Frecuencia")

```
```{r}
hist(datos_censo$num_personas_hogar,
     breaks = 20,
     col = "skyblue",
     main = "Distribuci√≥n de Personas Hogar",
     xlab = "Personas por Hogar",
     ylab = "Frecuencia")

```
```{r}
# Se utilizo como criterio de segemntacion 4 personas pro habitacion para que el criterio de validacion no sacara hogares en situacion de emergencia habitacional ya que el estipulado por el Banco mundial es 3 
datos_censo <- datos_censo %>%
  mutate(
    personas_por_pieza = num_personas_hogar / num_dormitorios,
    valido_habitacional = ifelse(is.na(personas_por_pieza), FALSE, personas_por_pieza <= 4)
  )

```

```{r}
datos_censo <- datos_censo %>%
  filter(valido_habitacional)
datos_censo <- datos_censo %>%
  select(-valido_habitacional)
# limpieza y borrado de columnas 
```

```{r}
datos_censo <- datos_censo %>%
  mutate(
    inconsistente_servicios = case_when(
      electricidad == "No" & (internet == "S√≠" | telefono_fijo == "S√≠") ~ TRUE,
      agua_potable == "No" & internet == "S√≠" & gas_natural == "S√≠" ~ TRUE,
      TRUE ~ FALSE
    )
  )

# Contar y guardar inconsistentes
cat("Casos con inconsistencias en servicios b√°sicos:", sum(datos_censo$inconsistente_servicios), "\n")

casos_inconsistentes_servicios <- datos_censo %>%
  filter(inconsistente_servicios)

# Eliminar de la base principal
datos_censo <- datos_censo %>%
  filter(!inconsistente_servicios) %>%
  select(-inconsistente_servicios)

```
```{r}
datos_censo <- datos_censo %>%
  mutate(
    indice_masculinidad = case_when(
      num_personas_hogar > 0 ~ round((num_hombres / num_personas_hogar) * 100, 1),
      TRUE ~ NA_real_
    )
  )
# El Indice fue creado contra habitantes del hogar para que sea mas facil su interpretaccion al quedar en porcentajes de 0 a 100%


```




# Se valid√≥ la coherencia interna en el acceso a servicios b√°sicos:
# - No es l√≥gico que un hogar sin electricidad tenga acceso a internet o tel√©fono fijo.
# - Tampoco es razonable que un hogar sin agua potable declare simult√°neamente tener internet y gas natural.
# Estos casos se consideraron inconsistentes y fueron eliminados para mantener integridad anal√≠tica.

```{r}
unique(select(datos_censo, tipo_vivienda,material_paredes, material_techo,))
# Vemos la conformacion de los datos antes de aplicar tecnica 
```

```{r}
datos_censo <- datos_censo %>%
  mutate(
    tipo_vivienda = str_to_title(stri_trans_general(tipo_vivienda, "Latin-ASCII")),
    material_paredes = str_to_title(stri_trans_general(material_paredes, "Latin-ASCII")),
    material_techo = str_to_title(stri_trans_general(material_techo, "Latin-ASCII"))
  )
# Vamos a aplicar tecnicaa de NPL para hacer la limpieza mas rapida
```

```{r}
datos_censo <- datos_censo %>%
  mutate(
    material_paredes = case_when(
      material_paredes %in% c("Wood") ~ "Madera",
      material_paredes %in% c("Hormigon", "hormigon") ~ "Hormig√≥n",
      TRUE ~ material_paredes
    ),
    
    material_techo = case_when(
      material_techo %in% c("Tejas", "tejas") ~ "Tejas",
      material_techo %in% c("Zinc", "ZINC") ~ "Zinc",
      material_techo %in% c("Losa") ~ "Losa",
      material_techo %in% c("Paja") ~ "Paja",
      TRUE ~ material_techo
    )
  )

```

```{r}
unique(datos_censo$tipo_vivienda)

# Se hace Validacion para ver si quedo correcto en vivienda
```
```{r}
datos_censo <- datos_censo %>%
  mutate(
    tipo_vivienda = str_to_title(stri_trans_general(tipo_vivienda, "Latin-ASCII")),
    tipo_vivienda = case_when(
      tipo_vivienda %in% c("Departam.", "Depto.", "Dpto") ~ "Departamento",
      tipo_vivienda == "Pareada" ~ "Casa Pareada",
      tipo_vivienda == "Media Agua" ~ "Mediagua",
      TRUE ~ tipo_vivienda
    )
  )
```

```{r}
unique(datos_censo$material_paredes)
```
```{r}
datos_censo <- datos_censo %>%
  mutate(
    material_paredes = case_when(
      material_paredes %in% c("Concrete", "Hormigon", "hormigon") ~ "Hormig√≥n",
      TRUE ~ material_paredes
    )
  )

```

```{r}
unique(datos_censo$material_techo)
```
```{r}
# Chapa se considero como techo de Zinc 
datos_censo <- datos_censo %>%
  mutate(
    material_techo = case_when(
      str_to_lower(material_techo) %in% c("zinc", "chapa") ~ "Zinc",
      str_to_lower(material_techo) %in% c("eternit") ~ "Fibrocemento",
      str_to_lower(material_techo) %in% c("tejas") ~ "Tejas",
      str_to_lower(material_techo) %in% c("losa") ~ "Losa",
      str_to_lower(material_techo) %in% c("paja") ~ "Paja",
      TRUE ~ str_to_title(material_techo)
    )
  )

```


```{r}
datos_censo %>%
  count(tipo_vivienda, material_paredes, material_techo) %>%
  arrange(desc(n))
# Compocision de materales no seria real , por lo que se van a a sumir algunos supuestos como que las mediaaguas no pueden ser de cemento 
```
```{r}
datos_censo %>%
  count(tipo_vivienda, material_paredes, material_techo) %>%
  arrange(desc(n))
```



```{r}
# Validaci√≥n de coherencia estructural seg√∫n tipo de vivienda
# Se consideran inconsistentes y son eliminadas:
# - Mediaguas que no tengan paredes de madera o techos pesados
#   Se endurece el criterio: ahora solo se permite techo de zinc (se excluye paja y chapa por est√°ndar actual).
# - Departamentos que tengan paredes de adobe o madera (materiales no compatibles con edificaciones verticales).
# - Departamentos con techos de paja (material precario y estructuralmente inviable para esa tipolog√≠a).
# - Casas pareadas construidas en adobe con techos de losa (por la incompatibilidad estructural del peso).
# - Casas de madera con techos de losa (por el peso excesivo sobre una estructura ligera).
# Estas condiciones buscan eliminar combinaciones constructivas poco plausibles dadas las restricciones f√≠sicas 
# y t√©cnicas comunes en edificaciones residenciales en contextos urbanos y rurales de Chile.


datos_censo <- datos_censo %>%
  mutate(
    inconsistencia_estructura = case_when(
      # Mediagua con pared no madera o techo no liviano
      tipo_vivienda == "Mediagua" &
        (str_to_lower(material_paredes) != "madera" |
         !(str_to_lower(material_techo) %in% c("zinc"))) ~ TRUE,  

      # Departamento con pared de madera o adobe
      tipo_vivienda == "Departamento" &
        str_to_lower(material_paredes) %in% c("madera", "adobe") ~ TRUE,

      # Departamento con techo de paja
      tipo_vivienda == "Departamento" &
        str_to_lower(material_techo) == "paja" ~ TRUE,

      # Casa Pareada con adobe y losa (peso estructural incoherente)
      tipo_vivienda == "Casa Pareada" &
        str_to_lower(material_paredes) == "adobe" &
        str_to_lower(material_techo) == "losa" ~ TRUE,

      # Casa con madera y losa
      tipo_vivienda == "Casa" &
        str_to_lower(material_paredes) == "madera" &
        str_to_lower(material_techo) == "losa" ~ TRUE,

      
      TRUE ~ FALSE
    )
  ) %>%
  filter(!inconsistencia_estructura) %>%
  select(-inconsistencia_estructura)



```


```{r}

ggplot(datos_censo, aes(x = tipo_vivienda, y = personas_por_pieza, fill = tipo_vivienda)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 1) +
  labs(
    title = "Densidad de personas por habitaci√≥n seg√∫n tipo de vivienda",
    x = "Tipo de vivienda",
    y = "Personas por habitaci√≥n"
  ) +
  theme_minimal() +
  theme(legend.position = "none")  

# Diferencias Irreleveantes a simple vista en Box plot 

```

```{r}
datos_censo <- datos_censo %>%
  mutate(across(c(agua_potable, electricidad, internet, gas_natural, telefono_fijo),
                ~ ifelse(. == "S√≠", 1, 0))) %>%
  mutate(servicios_disponibles = agua_potable + electricidad + internet + gas_natural + telefono_fijo)

```

```{r}


ggplot(datos_censo, aes(x = factor(servicios_disponibles), y = ingreso_mensual_hogar, fill = factor(servicios_disponibles))) +
  geom_boxplot(outlier.color = "red", outlier.shape = 1) +
  scale_fill_brewer(palette = "Set2") +  # Cambia el esquema de colores si prefieres otro
  scale_y_continuous(labels = comma) +  # Evita notaci√≥n cient√≠fica
  labs(
    title = "Relaci√≥n entre ingreso del hogar y servicios b√°sicos disponibles",
    x = "Cantidad de servicios disponibles (0 a 5)",
    y = "Ingreso mensual del hogar",
    fill = "Servicios"
  ) +
  theme_minimal()


```

# En este caso se sugiere revisar el ingreso per c√°pita, ya que la distribuci√≥n del ingreso mensual total por hogar
 podr√≠a ocultar desigualdades internas debido al tama√±o del grupo familiar.
 Aunque la media y la mediana del ingreso mensual son similares, lo que sugiere una distribuci√≥n cercana a la simetr√≠a,
 el indicador per c√°pita permite detectar hogares con ingresos bajos debido a que se ajusta por n√∫mero de personas.



```{r}
# Calcular l√≠mites del IQR
q1 <- quantile(datos_censo$ingreso_mensual_hogar, 0.25, na.rm = TRUE)
q3 <- quantile(datos_censo$ingreso_mensual_hogar, 0.75, na.rm = TRUE)
iqr <- q3 - q1

limite_inferior <- q1 - 1.5 * iqr
limite_superior <- q3 + 1.5 * iqr

# Marcar outliers
datos_censo <- datos_censo %>%
  mutate(outlier_ingresos = ingreso_mensual_hogar < limite_inferior | ingreso_mensual_hogar > limite_superior)

# Iqr para detectear Outlier y tomar decision sobre indice 

```

```{r}
summary(datos_censo$ingreso_mensual_hogar)

#Justificaci√≥n del √≠ndice de ingreso per c√°pita

#Durante la revisi√≥n de la variable ingreso_mensual_hogar, se observ√≥ que tanto la media (CLP $1.654.392) como la mediana (CLP $1.661.858) presentaban valores muy similares. Esto podr√≠a sugerir una distribuci√≥n aparentemente sim√©trica y sin sesgos, lo cual es enga√±oso, ya que no considera el tama√±o del hogar.
```
```{r}
ggplot(datos_censo, aes(x = ingreso_mensual_hogar)) +
  geom_histogram(aes(y = ..density..), binwidth = 200000, fill = "lightblue", color = "black") +
  geom_density(color = "darkblue", size = 1.2) +
  geom_vline(aes(xintercept = mean(ingreso_mensual_hogar, na.rm = TRUE)), color = "red", linetype = "dashed") +
  geom_vline(aes(xintercept = median(ingreso_mensual_hogar, na.rm = TRUE)), color = "green", linetype = "dashed") +
  labs(
    title = "Distribuci√≥n del ingreso mensual del hogar",
    x = "Ingreso mensual",
    y = "Densidad"
  ) +
  theme_minimal()

```

```{r}
# Creacion del indice 
datos_censo <- datos_censo %>%
  mutate(
    ingreso_per_capita = ifelse(num_personas_hogar > 0, ingreso_mensual_hogar / num_personas_hogar, NA)
  )

```

```{r}
summary(datos_censo$ingreso_per_capita)

```
```{r}
ggplot(datos_censo, aes(x = ingreso_per_capita)) +
  geom_histogram(binwidth = 50000, fill = "lightgreen", color = "black") +
  geom_density(aes(y = ..count..), color = "darkgreen", size = 1.2) +
  labs(
    title = "Distribuci√≥n del ingreso per c√°pita",
    x = "Ingreso per c√°pita",
    y = "Frecuencia"
  ) +
  theme_minimal()

```
# La diferencia entre la media (497.610) y la mediana (289.432) del ingreso per c√°pita evidencia un sesgo positivo,
lo que sugiere que existen hogares con ingresos per c√°pita muy altos que influyen en el promedio.
Por lo tanto, el ingreso per c√°pita es m√°s representativo para evaluar condiciones socioecon√≥micas que el ingreso total e procede a hacer los graficos con ingreso per capita .

```{r}
ggplot(datos_censo, aes(x = factor(servicios_disponibles), y = ingreso_per_capita, fill = factor(servicios_disponibles))) +
  geom_boxplot(outlier.color = "red", outlier.shape = 1) +
  scale_fill_brewer(palette = "Set2") +  
  scale_y_continuous(labels = scales::comma) +  
  labs(
    title = "Relaci√≥n entre ingreso per c√°pita y servicios b√°sicos disponibles",
    x = "Cantidad de servicios disponibles (0 a 5)",
    y = "Ingreso mensual per c√°pita (CLP)",
    fill = "Servicios"
  ) +
  theme_minimal()

```

```{r}
ggplot(datos_censo, aes(x = ingreso_per_capita)) +
  geom_histogram(aes(y = ..density..), binwidth = 200000, fill = "lightblue", color = "black") +
  geom_density(color = "darkblue", size = 1.2) +
  geom_vline(aes(xintercept = mean(ingreso_per_capita, na.rm = TRUE)), 
             color = "red", linetype = "dashed", size = 1, show.legend = TRUE) +
  geom_vline(aes(xintercept = median(ingreso_per_capita, na.rm = TRUE)), 
             color = "green", linetype = "dashed", size = 1, show.legend = TRUE) +
  annotate("text", x = mean(datos_censo$ingreso_per_capita, na.rm = TRUE), 
           y = 0.000005, label = "Media", color = "red", angle = 90, vjust = -0.5) +
  annotate("text", x = median(datos_censo$ingreso_per_capita, na.rm = TRUE), 
           y = 0.000005, label = "Mediana", color = "green", angle = 90, vjust = -0.5) +
  scale_x_continuous(labels = comma) +
  labs(
    title = "Distribuci√≥n del ingreso mensual per c√°pita",
    x = "Ingreso mensual per c√°pita (CLP)",
    y = "Densidad"
  ) +
  theme_minimal()

```

```{r}
colSums(is.na(datos_censo)) # Revision de Valores Na
```
```{r}
datos_censo <- datos_censo %>%
  mutate(score_calidad = 100)  # Puntaje inicial perfecto

```


## Objetivo del an√°lisis

Este informe tiene como objetivo explorar la calidad y estructura de los datos de vivienda en un censo, con √©nfasis en la validaci√≥n de coherencia interna, estructural y sociodemogr√°fica. Se busca identificar patrones asociados al nivel socioecon√≥mico del hogar y su acceso a servicios b√°sicos, utilizando t√©cnicas estad√≠sticas cl√°sicas y de machine learning (regresi√≥n log√≠stica y Random Forest). Adem√°s, se desarrolla un √≠ndice de calidad del registro y se examina la composici√≥n f√≠sica de la vivienda como posible predictor del ingreso per c√°pita.






```{r}
datos_censo <- datos_censo %>%
  mutate(
    # Penalizaci√≥n por NAs cr√≠ticos
    score_calidad = ifelse(is.na(num_personas_hogar) | num_personas_hogar == 0, score_calidad - 25, score_calidad),
    score_calidad = ifelse(is.na(num_dormitorios) | num_dormitorios == 0, score_calidad - 15, score_calidad),
    score_calidad = ifelse(is.na(ingreso_mensual_hogar), score_calidad - 20, score_calidad),
    
    # Penalizaci√≥n por outliers en ingreso total
    score_calidad = ifelse(outlier_ingresos, score_calidad - 10, score_calidad),
    
    # Penalizaci√≥n por densidad habitacional excesiva (>4)
    score_calidad = ifelse(personas_por_pieza > 4, score_calidad - 10, score_calidad),
    
    # Penalizaci√≥n por servicios bajos (0 o 1)
    score_calidad = ifelse(servicios_disponibles <= 1, score_calidad - 10, score_calidad),
    
    # Penalizaci√≥n si √≠ndice de masculinidad no se puede calcular
    score_calidad = ifelse(is.na(indice_masculinidad), score_calidad - 5, score_calidad),
    
    # Penalizaci√≥n por inconsistencias estructurales (ya fueron filtradas, pero si se reutiliza en otra base puede reactivarse)
    score_calidad = ifelse(tipo_vivienda == "Mediagua" & material_paredes != "Madera", score_calidad - 10, score_calidad),
    
    # Ajuste final: ning√∫n hogar puede tener score < 0
    score_calidad = pmax(score_calidad, 0)
  )
# Calcular media y desviaci√≥n est√°ndar del ingreso per c√°pita
media_pc <- mean(datos_censo$ingreso_per_capita, na.rm = TRUE)
sd_pc <- sd(datos_censo$ingreso_per_capita, na.rm = TRUE)

# Penalizaci√≥n por distancia respecto a la media (cada desviaci√≥n = -10 puntos)
datos_censo <- datos_censo %>%
  mutate(
    desvio_std_ingreso_pc = abs(ingreso_per_capita - media_pc) / sd_pc,
    score_calidad = score_calidad - round(desvio_std_ingreso_pc) * 10,
    score_calidad = pmax(score_calidad, 0)  # No permitir puntajes negativos
  )



```

# Sistema de Scoring de Calidad del Registro

Se implement√≥ un sistema de `score_calidad` que parte en 100 puntos para cada registro y es penalizado seg√∫n diversas condiciones que reflejan posibles problemas de calidad en los datos. Este sistema permite evaluar la **confiabilidad** relativa de cada observaci√≥n, priorizando aquellas que presentan informaci√≥n completa, coherente y plausible.

## Penalizaciones aplicadas:

- **Variables cr√≠ticas faltantes o inv√°lidas:**
  - `num_personas_hogar` ausente o igual a 0: ‚Äì25 puntos.
  - `num_dormitorios` ausente o igual a 0: ‚Äì15 puntos.
  - `ingreso_mensual_hogar` ausente: ‚Äì20 puntos.

- **Sospechas estructurales o inconsistencias:**
  - Ingreso mensual del hogar detectado como outlier por IQR: ‚Äì10 puntos.
  - M√°s de 4 personas por dormitorio (`personas_por_pieza > 4`): ‚Äì10 puntos.
  - Disponibilidad de 0 o 1 servicios b√°sicos: ‚Äì10 puntos.
  - √çndice de masculinidad no calculable (NA): ‚Äì5 puntos.
  - Vivienda tipo "Mediagua" con paredes distintas a "Madera": ‚Äì10 puntos.

- **Distancia respecto a la media del ingreso per c√°pita:**
  - Por cada desviaci√≥n est√°ndar de diferencia con la media: ‚Äì10 puntos.

## Consideraciones adicionales:
- Se asegura que ning√∫n puntaje final sea menor a 0 mediante `pmax(score_calidad, 0)`.
- Este sistema es **modular** y permite incorporar nuevas penalizaciones f√°cilmente seg√∫n los objetivos anal√≠ticos.
- Permite segmentar registros por confiabilidad, ayudando a filtrar, ponderar o analizar subgrupos seg√∫n su calidad de datos.
- se pudo hacer por combincaciones posibles de estructuras de vivienda , pero en rigor del tiempo hubiera procesado tiempo 

```{r}
datos_censo <- datos_censo %>%
  mutate(
    categoria_calidad = case_when(
      score_calidad >= 90 ~ "Alta",
      score_calidad >= 70 ~ "Media",
      TRUE ~ "Baja"
    )
  )

```



```{r}
ggplot(datos_censo, aes(x = score_calidad, fill = categoria_calidad)) +
  geom_histogram(binwidth = 5, color = "black", alpha = 0.8) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Distribuci√≥n del score de calidad de los registros",
       x = "Score de calidad",
       y = "Cantidad de viviendas",
       fill = "Categor√≠a") +
  theme_minimal()

```
```{r}
variables_pca <- datos_censo %>%
  select(num_dormitorios, num_banos, superficie_m2, num_personas_hogar,
         num_hombres, num_mujeres, num_menores_18, num_adultos_18_64, num_adultos_65_plus,
           ingreso_mensual_hogar, ingreso_per_capita, personas_por_pieza, 
         indice_masculinidad, jefe_hogar_edad) %>%
  drop_na()  # Eliminamos registros incompletos para el PCA

datos_pca_scaled <- scale(variables_pca)
pca_resultado <- prcomp(datos_pca_scaled, center = TRUE, scale. = TRUE)
summary(pca_resultado)
fviz_eig(pca_resultado, addlabels = TRUE, ylim = c(0, 50))

fviz_pca_var(pca_resultado, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)

```
## An√°lisis de Componentes Principales (PCA)

Se aplic√≥ un an√°lisis de componentes principales (PCA) a 14 variables socioecon√≥micas y de vivienda estandarizadas para identificar las dimensiones latentes que mejor explican la variabilidad de los datos.

### Varianza explicada:

- El primer componente (PC1) explica el **30,5%** de la varianza, seguido por PC2 con un **12,9%**, acumulando un **43,4%** entre ambos.
- Con **4 componentes** se explica m√°s del **60%** de la varianza (**60,5%**), lo que sugiere que existe una estructura subyacente reducida que captura buena parte de la informaci√≥n.

### Variables m√°s influyentes:

En el gr√°fico de contribuci√≥n de variables (c√≠rculo de correlaciones), se observa que:

- **`num_hombres`**, **`indice_masculinidad`**, **`num_mujeres`** y **`num_personas_hogar`** son las variables con mayor carga en el **primer componente (PC1)**.
- Estas variables representan la dimensi√≥n **demogr√°fica**, indicando que el tama√±o del hogar y su composici√≥n por g√©nero son factores estructurales fundamentales.
- **`ingreso_mensual_hogar`**, **`ingreso_per_capita`** y **`jefe_hogar_edad`** tienen contribuciones importantes en el **segundo componente (PC2)**, alineados con una dimensi√≥n **socioecon√≥mica**.

### Interpretaci√≥n general:

- El an√°lisis sugiere que los hogares pueden diferenciarse principalmente por su **estructura demogr√°fica (PC1)** y sus **condiciones econ√≥micas (PC2)**.
- El **√≠ndice de masculinidad**, al ser altamente influyente, podr√≠a estar capturando distorsiones en la declaraci√≥n de sexo dentro del hogar o reflejar composiciones familiares at√≠picas.
- La **densidad por habitaci√≥n** (`personas_por_pieza`) tambi√©n contribuye moderadamente, indicando su relevancia para caracterizar situaciones de **hacinamiento**.

Lo anterior siguiere que realizar un analisis de correlacion entre caracteristicas de la vivienda e ingresos un buen segmentador 

```{r}
# Kruskal-Wallis para ingreso_per_capita seg√∫n tipo_vivienda
kruskal.test(ingreso_per_capita ~ tipo_vivienda, data = datos_censo)

# Kruskal-Wallis para ingreso_per_capita seg√∫n material_paredes
kruskal.test(ingreso_per_capita ~ material_paredes, data = datos_censo)

# Kruskal-Wallis para ingreso_per_capita seg√∫n material_techo
kruskal.test(ingreso_per_capita ~ material_techo, data = datos_censo)

```
# Interpretacion 
- Se desprende que individualmente las caracteristicas de compocision de la viviendas no tienen diferencias significativas entre ingresos Per Capita 

- Se Procede a unir para ver si en conjutno si la tienen 
-Kruskal-Wallis se utilizo por que la variable ingreso per capita no mantiene distribcuion normal 

```{r}
datos_censo <- datos_censo %>%
  mutate(vivienda_compuesta = paste(tipo_vivienda, material_paredes, material_techo, sep = "_"))

```

```{r}
kruskal.test(ingreso_per_capita ~ vivienda_compuesta, data = datos_censo)

```
### An√°lisis de diferencias en ingreso per c√°pita seg√∫n caracter√≠sticas de vivienda

Se evalu√≥ si exist√≠an diferencias significativas en el ingreso per c√°pita seg√∫n las caracter√≠sticas f√≠sicas de la vivienda:

- Tipo de vivienda
- Material de paredes
- Material de techo

Dado que la variable `ingreso_per_capita` no sigue una distribuci√≥n normal, se utiliz√≥ el test no param√©trico de Kruskal-Wallis para comparar medianas entre grupos, tanto para cada variable individual como para una variable compuesta (`vivienda_compuesta`) que agrupa las tres caracter√≠sticas.

**Resultado:**  
Kruskal-Wallis chi-squared = 46.852, df = 47, p-value = 0.4786

**Interpretaci√≥n:**  
No se encontraron diferencias estad√≠sticamente significativas en el ingreso per c√°pita seg√∫n los distintos perfiles estructurales de vivienda.

Esto sugiere que, en esta muestra, las condiciones materiales del hogar no est√°n fuertemente asociadas al ingreso disponible por persona, al menos desde el punto de vista estad√≠stico.

```{r}
# Calcular el total de registros por comuna
top_comunas <- datos_censo %>%
  count(comuna, sort = TRUE) %>%
  top_n(10, n) %>%
  pull(comuna)

# Filtrar solo esas comunas
datos_top <- datos_censo %>%
  filter(comuna %in% top_comunas)

# Agrupar por comuna y tipo estructural compuesto
datos_top <- datos_top %>%
  group_by(comuna, vivienda_compuesta) %>%
  summarise(freq = n(), .groups = "drop") %>%
  group_by(comuna) %>%
  mutate(proporcion = freq / sum(freq)) %>%
  arrange(comuna, desc(proporcion)) %>%
  slice_head(n = 1)  # Elegir el patr√≥n m√°s frecuente por comuna

# Mostrar resultado
datos_top



```

**Hallazgos clave sobre distribuci√≥n de tipos de vivienda:**

1. **Patrones predominantes:**
   - üèòÔ∏è **Casa pareada** emerge como tipolog√≠a recurrente en m√∫ltiples comunas (Las Condes, Los Andes, Providencia, Santiago)
   - üß± **Adobe** mantiene alta prevalencia como material constructivo (Concepci√≥n, Las Condes, Providencia, Santiago)
   - üè´ **Zinc** domina como material de techado (presente en 7 de 10 casos analizados)

2. **Distribuci√≥n geogr√°fica:**
   - üìç Concentraci√≥n en **zona centro** del pa√≠s (desde Valpara√≠so a Concepci√≥n)
   - Excepciones en extremos: Puerto Montt (sur) y Punta Arenas (extremo sur)

3. **Casos destacados:**
   - M√°xima proporci√≥n: Las Condes (Casa Pareada_Adobe_Tejas - 5.96%)
   - Combinaci√≥n inusual: Punta Arenas (Casa_Hormig√≥n_Zinc - 5.02%)
   - Patr√≥n moderno: Valpara√≠so (Departamento_Hormig√≥n_Tejas - 4.32%)

**Interpretaci√≥n socio-constructiva:**
- La persistencia del **adobe** (tradici√≥n constructiva) junto al **zinc** (material econ√≥mico) revela procesos h√≠bridos de desarrollo urbano
- Las **casas pareadas** sugieren densificaci√≥n intermedia en zonas urbanas consolidadas
- La muestra confirma la **centralidad geogr√°fica** del fen√≥meno analizado, con adaptaciones locales en extremos sur

```{r}
datos_censo <- datos_censo %>%
  mutate(
    ingreso_alto = ifelse(ingreso_per_capita > 2000000, 1, 0)
  )
```

```{r}
set.seed(123)
# Convertir la variable objetivo a factor (importante para glm)
datos_censo <- datos_censo %>% 
  mutate(ingreso_alto = as.factor(ingreso_alto))

# Modelo de regresi√≥n log√≠stica
modelo_logit <- glm(ingreso_alto ~ 
                     comuna + 
                     tipo_vivienda + 
                     num_dormitorios + 
                     num_banos + 
                     superficie_m2 + 
                     material_paredes + 
                     jefe_hogar_edad + 
                     jefe_hogar_sexo + 
                     jefe_hogar_educacion,
                   data = datos_censo,
                   family = binomial(link = "logit"))  # Especificamos que es log√≠stica

# Resumen del modelo
summary(modelo_logit)
```lo_rf <- randomForest(ingreso_alto ~ .,
                         data = datos_censo,  
                         ntree = 500,
                         importance = TRUE)

# Evaluaci√≥n b√°sica
print(modelo_rf)  
varImpPlot(modelo_rf)
```

```{r}
# Convertir ingreso_alto a factor si no lo est√°
datos_censo <- datos_censo %>%
  mutate(ingreso_alto = as.factor(ingreso_alto))

# Reutilizar funci√≥n para intervalo
ic_media <- function(x, nivel = 0.95) {
  n <- length(x)
  media <- mean(x, na.rm = TRUE)
  error <- qt(1 - (1 - nivel)/2, df = n - 1) * sd(x, na.rm = TRUE) / sqrt(n)
  c(inf = media - error, media = media, sup = media + error)
}

# Calcular estad√≠sticas por ingreso_alto
ic_ingreso_alto <- datos_censo %>%
  group_by(ingreso_alto) %>%
  summarise(
    media = mean(ingreso_per_capita, na.rm = TRUE),
    mediana = median(ingreso_per_capita, na.rm = TRUE),
    n = n(),
    ic_inf = ic_media(ingreso_per_capita)[1],
    ic_central = ic_media(ingreso_per_capita)[2],
    ic_sup = ic_media(ingreso_per_capita)[3]
  )

ic_ingreso_alto

```
# Validaci√≥n estad√≠stica de la variable `ingreso_alto`

Se valid√≥ la variable `ingreso_alto` con un nivel de confianza del 95% para evaluar la solidez de su aplicaci√≥n como variable objetivo en modelos predictivos. Al comparar los grupos (hogares con ingreso per c√°pita mayor a $2.000.000 y el resto), se observ√≥ que:

- Las **medias y medianas** de ingreso per c√°pita difieren ampliamente entre ambos grupos.
- Los **intervalos de confianza del 95%** para la media no se superponen, lo que indica una **diferencia estad√≠sticamente significativa** entre ambos segmentos.

Esta validaci√≥n respalda el uso de `ingreso_alto` como una **variable confiable y representativa** para identificar hogares de alto ingreso dentro de la muestra, con sustento estad√≠stico suficiente para alimentar modelos de clasificaci√≥n como regresi√≥n log√≠stica o Random Forest.



```{r}
# Modelo de regresi√≥n log√≠stica corregido y optimizado
modelo_logit2<- glm(ingreso_alto ~ tipo_vivienda + 
                    num_dormitorios + 
                    num_banos + 
                    superficie_m2 + 
                    material_paredes + 
                    jefe_hogar_edad + 
                    jefe_hogar_sexo + 
                    jefe_hogar_educacion,
                  data = datos_censo,
                  family = binomial(link = "logit"))

# Resumen mejorado del modelo
summary(modelo_logit2)
```
**Hallazgos Clave sobre Dormitorios e Ingresos Altos:**

 **Relaci√≥n inversa significativa**  
   - El an√°lisis confirma que hogares con **menos dormitorios** tienen mayor probabilidad de ingresos altos (>2M)  
   - Cada dormitorio adicional reduce la odds de ingreso alto en ~30% (OR ‚âà 0.7, p < 0.001)


**Limitaci√≥n metodol√≥gica**  
   - Los modelos de regresi√≥n tradicionales subestiman este fen√≥meno por:  
     ‚úì Distribuci√≥n no-lineal de ingresos altos  
     ‚úì Efectos de composici√≥n no capturados  

**Recomendaci√≥n anal√≠tica:**  
Complementar con:  
- An√°lisis georreferenciados (hotspots de ingresos altos)  
- Segmentaci√≥n por tipolog√≠a familiar

> **Nota sobre la validaci√≥n del modelo logit:**  
> No se aplic√≥ validaci√≥n cruzada ni partici√≥n entrenamiento/prueba, debido a que el modelo mostr√≥ una capacidad predictiva muy baja desde el inicio. Dado que la proporci√≥n de hogares con ingresos per c√°pita superiores a $2.000.000 era extremadamente baja, cualquier segmentaci√≥n de la base habr√≠a reducido a√∫n m√°s la representatividad del evento, evidenciando el fen√≥meno pero sin mejorar la capacidad predictiva del modelo. En este contexto, se opt√≥ por priorizar la interpretaci√≥n de coeficientes sobre m√©tricas de clasificaci√≥n.


```{r}
datos_censo <- datos_censo %>%
  mutate(
    nivel_socioeco = case_when(
      ingreso_per_capita >= quantile(ingreso_per_capita, 0.75, na.rm = TRUE) ~ "Alto",
      ingreso_per_capita <= quantile(ingreso_per_capita, 0.25, na.rm = TRUE) ~ "Bajo",
      TRUE ~ "Medio"
    ),
    nivel_socioeco = factor(nivel_socioeco, levels = c("Bajo", "Medio", "Alto"))
  )


```

```{r}
table(datos_censo$nivel_socioeco)
```
```{r}
# Funci√≥n para IC de la media
ic_media <- function(x, nivel = 0.95) {
  n <- length(x)
  media <- mean(x, na.rm = TRUE)
  error <- qt(1 - (1 - nivel)/2, df = n - 1) * sd(x, na.rm = TRUE) / sqrt(n)
  c(inferior = media - error, media = media, superior = media + error)
}

# Calcular para cada grupo
ic_por_grupo <- datos_censo %>%
  group_by(nivel_socioeco) %>%
  summarise(
    media = mean(ingreso_per_capita, na.rm = TRUE),
    mediana = median(ingreso_per_capita, na.rm = TRUE),
    n = n(),
    ic_media_inf = ic_media(ingreso_per_capita)[1],
    ic_media_central = ic_media(ingreso_per_capita)[2],
    ic_media_sup = ic_media(ingreso_per_capita)[3]
  )

ic_por_grupo
```
```{r}
ggplot(ic_por_grupo, aes(x = nivel_socioeco, y = ic_media_central)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = ic_media_inf, ymax = ic_media_sup), width = 0.2) +
  labs(
    title = "Ingreso per c√°pita: Media e Intervalo de Confianza por Nivel Socioecon√≥mico",
    x = "Nivel Socioecon√≥mico",
    y = "Ingreso per c√°pita (CLP)"
  ) +
  scale_y_continuous(labels = scales::comma) +
  theme_minimal()
```
```{r}
# Diccionario de comunas con su respectiva regi√≥n
asociaciones_comunas <- c(
  "Arica" = "Arica y Parinacota",
  "Putre" = "Arica y Parinacota",
  "Iquique" = "Tarapac√°",
  "Alto Hospicio" = "Tarapac√°",
  "Calama" = "Antofagasta",
  "Antofagasta" = "Antofagasta",
  "Copiapo" = "Atacama",
  "Vallenar" = "Atacama",
  "La Serena" = "Coquimbo",
  "Ovalle" = "Coquimbo",
  "Coquimbo" = "Coquimbo",
  "Valpara√≠so" = "Valpara√≠so",
  "San Antonio" = "Valpara√≠so",
  "Quillota" = "Valpara√≠so",
  "Los Andes" = "Valpara√≠so",
  "Vi√±a Del Mar" = "Valpara√≠so",
  "Quilpue" = "Valpara√≠so",
  "Villa Alemana" = "Valpara√≠so",
  "Santiago" = "Metropolitana",
  "Puente Alto" = "Metropolitana",
  "Maipu" = "Metropolitana",
  "Nunoa" = "Metropolitana",
  "La Florida" = "Metropolitana",
  "Las Condes" = "Metropolitana",
  "Providencia" = "Metropolitana",
  "San Bernardo" = "Metropolitana",
  "Rancagua" = "O'Higgins",
  "San Fernando" = "O'Higgins",
  "Curico" = "Maule",
  "Talca" = "Maule",
  "Chillan" = "√ëuble",
  "Los Angeles" = "Biob√≠o",
  "Talcahuano" = "Biob√≠o",
  "Concepci√≥n" = "Biob√≠o",
  "Temuco" = "La Araucan√≠a",
  "Villarrica" = "La Araucan√≠a",
  "Valdivia" = "Los R√≠os",
  "Osorno" = "Los Lagos",
  "Puerto Montt" = "Los Lagos",
  "Castro" = "Los Lagos",
  "Coyhaique" = "Ays√©n",
  "Punta Arenas" = "Magallanes"
)

```

```{r}
datos_censo <- datos_censo %>%
  mutate(region = asociaciones_comunas[as.character(comuna)])
```

```{r}
# Calcular proporci√≥n de hogares con ingreso alto por regi√≥n
resumen_region <- datos_censo %>%
  filter(!is.na(region)) %>%
  group_by(region) %>%
  summarise(
    total = n(),
    con_ingreso_alto = sum(as.numeric(as.character(ingreso_alto)) == 1, na.rm = TRUE),
    prop_alto = con_ingreso_alto / total
  )
```

```{r}
tabla_region <- datos_censo %>%
  filter(!is.na(region)) %>%
  group_by(region) %>%
  summarise(
    Total_hogares = n(),
    Con_ingreso_alto = sum(as.numeric(as.character(ingreso_alto)) == 1, na.rm = TRUE),
    Proporcion_alto = Con_ingreso_alto / Total_hogares
  ) %>%
  arrange(desc(Proporcion_alto)) %>%
  mutate(Proporcion_alto = scales::percent(Proporcion_alto, accuracy = 0.1))
print(tabla_region)
```



